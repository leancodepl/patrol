# Continuous integration

Having test doesn't bring you any benefits if you don't automatically verify
that they pass. We know this too well, so we've put a lot of work into making it
easy to run Patrol tests in a multitude of ways, so you can choose whatever
suits you best.

Patrol tests can be run as _native instrumentation tests_ on both iOS and
Android. What does it mean and what's cool about it?

## What are native tests good for, anyway?

iOS and Android have existed for more than 15 years, and during that time many
of awesome testing-related things were built around them ‚Äì open-source test
runners, device farms, HTML report generators. Developers who create native
mobile apps can easily reap benefits from this huge, mature ecosystem.

Meanwhile we, Flutter developers, don't have as much at our disposal. Our
framework is much younger and less mature.

What if we could masquarade our Flutter tests so that from the outside they
would be truly native? This way we leverage many existing tools while
maintaining the convenience of writing the tests in pure Dart.

> For example, you can run your Patrol tests directly from Xcode. Xcode knows
> nothing about Flutter, Dart and Patrol ‚Äì it only launches your test app.
> Flutter tests are then run inside the test app and the results are reported
> back to Xcode. This way you get the best of both worlds ‚Äì the maturity of
> native iOS development and the produtivity of Flutter and Dart.

That's exactly what Patrol does (and what the default [integration_test] package
does at well, but at a bit smaller scale).

Take a look at this simple Patrol test:

```dart
void main() {
  patrolTest(
    'counter state is the same after going to Home and switching apps',
    nativeAutomatorConfig: NativeAutomatorConfig(
      packageName: 'pl.leancode.patrol.example',
      bundleId: 'pl.leancode.patrol.Example',
    ),
    nativeAutomation: true,
    ($) async {
      await $.pumpWidget(ExampleApp());

      await $(FloatingActionButton).tap();
      expect($(#counterText).text, '1');

      await $.native.pressHome();
      await $.native.openApp();

      expect($(#counterText).text, '1');

      await $(FloatingActionButton).tap();
      expect($(#counterText).text, '2');
    },
  );
}
```

You can run this test and view its results in many ways, using all sorts of
different tools, platforms, and IDEs:

<Tabs
  defaultValue="studio"
  values={[
    { label: "Android Studio", value: "studio" },
    { label: "Xcode", value: "xcode" },
    { label: "Firebase Test Lab", value: "testlab" },
    { label: "Gradle", value: "gradle" },
    { label: "fastlane scan", value: "xcpretty" },
  ]}
>
  <TabItem value="studio">
    When Android test finishes, its test results are automatically generated in
    `build/app/outputs/androidTest-results/connected/test-result.pb`. To view
    them in Android Studio, use the `Run > Import tests from file` option.

    ![Patrol test results in Android
    Studio](/assets/android_test_results_as.png)

  </TabItem>
  <TabItem value="xcode">
    ![Patrol test results in Xcode](/assets/ios_test_results_xcode.png)
  </TabItem>
  <TabItem value="testlab">
    It just works ‚ú®

    ![Patrol test results in Firebase Test
    Lab](/assets/android_test_results_firebase.png)

  </TabItem>
  <TabItem value="gradle">
    You don't have to use the bulky Android Studio to view your test results,
    because Gradle üêò automatically generate a nice HTML summary!

    You can find it in `build/app/reports/androidTests/connected/index.html`.

    ![Patrol test results generated by Gradle](/assets/android_test_results_gradle.png)

  </TabItem>
  <TabItem value="xcpretty">
    With the help of awesome [fastlane scan] you can prettify the output of
    `xcodebuild` to make it easier to understand and generate HTML summary of
    your tests.

    ![Patrol test results generated by xcpretty](/assets/ios_test_results_xcpretty.png)

  </TabItem>
</Tabs>

This is so awesome!

## Setup

Android is a bit easier to set up, so we recommend starting with it!

<Tabs 
  defaultValue="android" 
  values={[
    { label: "Android", value: "android" },
    { label: "iOS", value: "ios" },
  ]}>
  <TabItem value="android">
    
      Create an instrumentation test file in your application's
      **android/app/src/androidTest/java/com/example/myapp/** directory (replacing
      com, example, and myapp with values from your app's package name). You can name
      this test file `MainActivityTest.java` or another name of your choice.

      ```java
      package pl.leancode.patrol.example; // replace with your app's package

      import dev.flutter.plugins.integration_test.FlutterTestRunner;
      import org.junit.Rule;
      import org.junit.runner.RunWith;
      import pl.leancode.patrol.PatrolTestRule;

      @RunWith(FlutterTestRunner.class)
      public class MainActivityTest {
          @Rule
          public PatrolTestRule<MainActivity> rule = new PatrolTestRule<>(MainActivity.class);
      }
      ```

      Next, update your **app-level build.gradle**:

      ```groovy
      android {
        // ...
        defaultConfig {
          //...
          testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        }
      }

      dependencies {
          testImplementation "junit:junit:4.13.2"
      }
      ```

      To run `integration_test/example_test.dart` on a local Android device (emulated or
      physical):

      ```bash
      $ ./gradlew app:connectedDebugAndroidTest -Ptarget=$(pwd)/../integration_test/example_test.dart
      ```

  </TabItem>
  <TabItem value="ios">

    Open `ios/Runner.xcworkspace` in Xcode. Create a test target if you
    do not already have one via `File > New > Target...` and select `UI Testing Bundle`.
    Change the `Product Name` to `RunnerUITests`. Make sure `Target to be Tested` is set to `Runner` and language is set to `Objective-C`.
    Select `Finish`.
    Make sure that the **iOS Deployment Target** of `RunnerTests` within the **Build Settings** section is the same as `Runner`.

    Add the new test target to `ios/Podfile` by embedding in the existing `Runner` target.

    ```ruby
    target 'Runner' do
      # Do not change existing lines.
      ...

      target 'RunnerUITests' do
        inherit! :complete
      end
    end
    ```

    To build `integration_test/example_test.dart` from the command line, run:

    ```bash
    $ flutter build ios --config-only integration_test/example_test.dart
    ```

    In Xcode, add a test file called `RunnerTests.m` (or any name of your choice) to the new target and
    replace the file:

    ```objective-c
    @import XCTest;
    @import integration_test;

    PATROL_INTEGRATION_TEST_IOS_RUNNER(RunnerTests)
    ```

    To run the test on a local iOS device (simulated or physical):
    - run `Product > Test` to run the integration tests on your selected device.
    - or click the "play" button on the last line of your test:

      ![Run tests natively on iOS](/assets/ios_run_test.png)

  </TabItem>
</Tabs>

## Run on Firebase Test Lab

There are many device lab providers. Below we're showing how to run Patrol tests
on [Firebase Test Lab], because it's popular in the Flutter community, but the
instructions should be similar for other device farms, such as [AWS Device
Farm][aws_device_farm] or [BrowserStack][browserstack].

<Tabs
  defaultValue="android"
  values={[
    { label: "Android", value: "android" },
    { label: "iOS", value: "ios" },
  ]}
>
  <TabItem value="android">
    To run the integration tests on Android, you need 2 apps:

    - the normal apk (often called the "app under test"). To build it, run:

      ```bash
      $ ./gradlew app:assembleDebug -Ptarget="$(pwd)/../integration_test/example_test.dart"
      ```

    - the intrumentation apk. To build it, run:

      ```bash
      $ ./gradlew app:assembleDebugAndroidTest
      ```

    You need to run the above commands from the `android` directory of your
    Flutter project.

    Once you have built the apks, use the [gcloud] tool to run them on Firebase
    Test Lab:

    ```bash
    $ gcloud firebase test android run --type instrumentation \
        --app build/app/outputs/apk/debug/app-debug.apk \
        --test build/app/outputs/apk/androidTest/debug/app-debug-androidTest.apk\
        --timeout 1m \
        --results-bucket=<RESULTS_BUCKET> \
        --results-dir=<RESULTS_DIRECTORY>
    ```

    You might also want to take a look at Patrol example app's
    [run_android_testlab script][example_android_script].

  </TabItem>
  <TabItem value="ios">Coming very soon</TabItem>
</Tabs>

[integration_test]: https://github.com/flutter/flutter/tree/master/packages/integration_test
[gcloud]: https://cloud.google.com/sdk/gcloud
[example_android_script]: https://github.com/leancodepl/patrol/blob/master/packages/patrol/example/run_android_testlab
[fastlane scan]: https://docs.fastlane.tools/actions/scan
[firebase test lab]: https://firebase.google.com/products/test-lab
[aws_device_farm]: https://aws.amazon.com/device-farm
[browserstack]: https://www.browserstack.com/app-automate
