// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: contracts.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Patrol_OpenAppCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Patrol_TapCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: String = String()

  var selector: Patrol_Selector {
    get {return _selector ?? Patrol_Selector()}
    set {_selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  var hasSelector: Bool {return self._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  mutating func clearSelector() {self._selector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _selector: Patrol_Selector? = nil
}

struct Patrol_DoubleTapCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: String = String()

  var selector: Patrol_Selector {
    get {return _selector ?? Patrol_Selector()}
    set {_selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  var hasSelector: Bool {return self._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  mutating func clearSelector() {self._selector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _selector: Patrol_Selector? = nil
}

struct Patrol_EnterTextBySelectorCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: String = String()

  var data: String = String()

  var selector: Patrol_Selector {
    get {return _selector ?? Patrol_Selector()}
    set {_selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  var hasSelector: Bool {return self._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  mutating func clearSelector() {self._selector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _selector: Patrol_Selector? = nil
}

struct Patrol_EnterTextByIndexCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: String = String()

  var data: String = String()

  var index: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Patrol_TapOnNotificationByIndexCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var index: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Patrol_TapOnNotificationBySelectorCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var selector: Patrol_Selector {
    get {return _selector ?? Patrol_Selector()}
    set {_selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  var hasSelector: Bool {return self._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  mutating func clearSelector() {self._selector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _selector: Patrol_Selector? = nil
}

struct Patrol_SwipeCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startX: Float = 0

  var startY: Float = 0

  var endX: Float = 0

  var endY: Float = 0

  var steps: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Patrol_HandlePermissionCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: Patrol_HandlePermissionCommand.Code = .whileUsing

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Code: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case whileUsing // = 0
    case onlyThisTime // = 1
    case denied // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .whileUsing
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .whileUsing
      case 1: self = .onlyThisTime
      case 2: self = .denied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .whileUsing: return 0
      case .onlyThisTime: return 1
      case .denied: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Patrol_HandlePermissionCommand.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Patrol_HandlePermissionCommand.Code] = [
    .whileUsing,
    .onlyThisTime,
    .denied,
  ]
}

#endif  // swift(>=4.2)

struct Patrol_Selector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String = String()

  var textStartsWith: String = String()

  var textContains: String = String()

  var className: String = String()

  var contentDescription: String = String()

  var contentDescriptionStartsWith: String = String()

  var contentDescriptionContains: String = String()

  var resourceID: String = String()

  var instance: UInt32 = 0

  var enabled: Bool = false

  var focused: Bool = false

  var pkg: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Patrol_NativeWidget {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var className: String = String()

  var text: String = String()

  var contentDescription: String = String()

  var focused: Bool = false

  var enabled: Bool = false

  var childCount: Int32 = 0

  var resourceName: String = String()

  var applicationPackage: String = String()

  var children: [Patrol_NativeWidget] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Patrol_NativeWidgetsQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var selector: Patrol_Selector {
    get {return _selector ?? Patrol_Selector()}
    set {_selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  var hasSelector: Bool {return self._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  mutating func clearSelector() {self._selector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _selector: Patrol_Selector? = nil
}

struct Patrol_Notification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appName: String = String()

  var title: String = String()

  var content: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Patrol_NotificationsQueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var notifications: [Patrol_Notification] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Patrol_NativeWidgetsQueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nativeWidgets: [Patrol_NativeWidget] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Patrol_OpenAppCommand: @unchecked Sendable {}
extension Patrol_TapCommand: @unchecked Sendable {}
extension Patrol_DoubleTapCommand: @unchecked Sendable {}
extension Patrol_EnterTextBySelectorCommand: @unchecked Sendable {}
extension Patrol_EnterTextByIndexCommand: @unchecked Sendable {}
extension Patrol_TapOnNotificationByIndexCommand: @unchecked Sendable {}
extension Patrol_TapOnNotificationBySelectorCommand: @unchecked Sendable {}
extension Patrol_SwipeCommand: @unchecked Sendable {}
extension Patrol_HandlePermissionCommand: @unchecked Sendable {}
extension Patrol_HandlePermissionCommand.Code: @unchecked Sendable {}
extension Patrol_Selector: @unchecked Sendable {}
extension Patrol_NativeWidget: @unchecked Sendable {}
extension Patrol_NativeWidgetsQuery: @unchecked Sendable {}
extension Patrol_Notification: @unchecked Sendable {}
extension Patrol_NotificationsQueryResponse: @unchecked Sendable {}
extension Patrol_NativeWidgetsQueryResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "patrol"

extension Patrol_OpenAppCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpenAppCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Patrol_OpenAppCommand, rhs: Patrol_OpenAppCommand) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_TapCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TapCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appId"),
    2: .same(proto: "selector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._selector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    try { if let v = self._selector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Patrol_TapCommand, rhs: Patrol_TapCommand) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs._selector != rhs._selector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_DoubleTapCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DoubleTapCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appId"),
    2: .same(proto: "selector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._selector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    try { if let v = self._selector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Patrol_DoubleTapCommand, rhs: Patrol_DoubleTapCommand) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs._selector != rhs._selector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_EnterTextBySelectorCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnterTextBySelectorCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appId"),
    2: .same(proto: "data"),
    3: .same(proto: "selector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._selector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 2)
    }
    try { if let v = self._selector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Patrol_EnterTextBySelectorCommand, rhs: Patrol_EnterTextBySelectorCommand) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.data != rhs.data {return false}
    if lhs._selector != rhs._selector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_EnterTextByIndexCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnterTextByIndexCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appId"),
    2: .same(proto: "data"),
    3: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Patrol_EnterTextByIndexCommand, rhs: Patrol_EnterTextByIndexCommand) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.data != rhs.data {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_TapOnNotificationByIndexCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TapOnNotificationByIndexCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Patrol_TapOnNotificationByIndexCommand, rhs: Patrol_TapOnNotificationByIndexCommand) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_TapOnNotificationBySelectorCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TapOnNotificationBySelectorCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "selector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._selector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._selector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Patrol_TapOnNotificationBySelectorCommand, rhs: Patrol_TapOnNotificationBySelectorCommand) -> Bool {
    if lhs._selector != rhs._selector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_SwipeCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SwipeCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startX"),
    2: .same(proto: "startY"),
    3: .same(proto: "endX"),
    4: .same(proto: "endY"),
    5: .same(proto: "steps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.startX) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.startY) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.endX) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.endY) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.steps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startX != 0 {
      try visitor.visitSingularFloatField(value: self.startX, fieldNumber: 1)
    }
    if self.startY != 0 {
      try visitor.visitSingularFloatField(value: self.startY, fieldNumber: 2)
    }
    if self.endX != 0 {
      try visitor.visitSingularFloatField(value: self.endX, fieldNumber: 3)
    }
    if self.endY != 0 {
      try visitor.visitSingularFloatField(value: self.endY, fieldNumber: 4)
    }
    if self.steps != 0 {
      try visitor.visitSingularUInt32Field(value: self.steps, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Patrol_SwipeCommand, rhs: Patrol_SwipeCommand) -> Bool {
    if lhs.startX != rhs.startX {return false}
    if lhs.startY != rhs.startY {return false}
    if lhs.endX != rhs.endX {return false}
    if lhs.endY != rhs.endY {return false}
    if lhs.steps != rhs.steps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_HandlePermissionCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HandlePermissionCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .whileUsing {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Patrol_HandlePermissionCommand, rhs: Patrol_HandlePermissionCommand) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_HandlePermissionCommand.Code: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WHILE_USING"),
    1: .same(proto: "ONLY_THIS_TIME"),
    2: .same(proto: "DENIED"),
  ]
}

extension Patrol_Selector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Selector"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "textStartsWith"),
    3: .same(proto: "textContains"),
    4: .same(proto: "className"),
    5: .same(proto: "contentDescription"),
    6: .same(proto: "contentDescriptionStartsWith"),
    7: .same(proto: "contentDescriptionContains"),
    8: .same(proto: "resourceId"),
    9: .same(proto: "instance"),
    10: .same(proto: "enabled"),
    11: .same(proto: "focused"),
    12: .same(proto: "pkg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.textStartsWith) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.textContains) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.className) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.contentDescription) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.contentDescriptionStartsWith) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.contentDescriptionContains) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.resourceID) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.instance) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.focused) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.pkg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.textStartsWith.isEmpty {
      try visitor.visitSingularStringField(value: self.textStartsWith, fieldNumber: 2)
    }
    if !self.textContains.isEmpty {
      try visitor.visitSingularStringField(value: self.textContains, fieldNumber: 3)
    }
    if !self.className.isEmpty {
      try visitor.visitSingularStringField(value: self.className, fieldNumber: 4)
    }
    if !self.contentDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.contentDescription, fieldNumber: 5)
    }
    if !self.contentDescriptionStartsWith.isEmpty {
      try visitor.visitSingularStringField(value: self.contentDescriptionStartsWith, fieldNumber: 6)
    }
    if !self.contentDescriptionContains.isEmpty {
      try visitor.visitSingularStringField(value: self.contentDescriptionContains, fieldNumber: 7)
    }
    if !self.resourceID.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceID, fieldNumber: 8)
    }
    if self.instance != 0 {
      try visitor.visitSingularUInt32Field(value: self.instance, fieldNumber: 9)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 10)
    }
    if self.focused != false {
      try visitor.visitSingularBoolField(value: self.focused, fieldNumber: 11)
    }
    if !self.pkg.isEmpty {
      try visitor.visitSingularStringField(value: self.pkg, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Patrol_Selector, rhs: Patrol_Selector) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.textStartsWith != rhs.textStartsWith {return false}
    if lhs.textContains != rhs.textContains {return false}
    if lhs.className != rhs.className {return false}
    if lhs.contentDescription != rhs.contentDescription {return false}
    if lhs.contentDescriptionStartsWith != rhs.contentDescriptionStartsWith {return false}
    if lhs.contentDescriptionContains != rhs.contentDescriptionContains {return false}
    if lhs.resourceID != rhs.resourceID {return false}
    if lhs.instance != rhs.instance {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.focused != rhs.focused {return false}
    if lhs.pkg != rhs.pkg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_NativeWidget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NativeWidget"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "className"),
    2: .same(proto: "text"),
    3: .same(proto: "contentDescription"),
    4: .same(proto: "focused"),
    5: .same(proto: "enabled"),
    6: .same(proto: "childCount"),
    7: .same(proto: "resourceName"),
    8: .same(proto: "applicationPackage"),
    9: .same(proto: "children"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.className) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contentDescription) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.focused) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.childCount) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.resourceName) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.applicationPackage) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.children) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.className.isEmpty {
      try visitor.visitSingularStringField(value: self.className, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    if !self.contentDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.contentDescription, fieldNumber: 3)
    }
    if self.focused != false {
      try visitor.visitSingularBoolField(value: self.focused, fieldNumber: 4)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 5)
    }
    if self.childCount != 0 {
      try visitor.visitSingularInt32Field(value: self.childCount, fieldNumber: 6)
    }
    if !self.resourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceName, fieldNumber: 7)
    }
    if !self.applicationPackage.isEmpty {
      try visitor.visitSingularStringField(value: self.applicationPackage, fieldNumber: 8)
    }
    if !self.children.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.children, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Patrol_NativeWidget, rhs: Patrol_NativeWidget) -> Bool {
    if lhs.className != rhs.className {return false}
    if lhs.text != rhs.text {return false}
    if lhs.contentDescription != rhs.contentDescription {return false}
    if lhs.focused != rhs.focused {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.childCount != rhs.childCount {return false}
    if lhs.resourceName != rhs.resourceName {return false}
    if lhs.applicationPackage != rhs.applicationPackage {return false}
    if lhs.children != rhs.children {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_NativeWidgetsQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NativeWidgetsQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "selector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._selector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._selector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Patrol_NativeWidgetsQuery, rhs: Patrol_NativeWidgetsQuery) -> Bool {
    if lhs._selector != rhs._selector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_Notification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Notification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appName"),
    2: .same(proto: "title"),
    3: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appName.isEmpty {
      try visitor.visitSingularStringField(value: self.appName, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Patrol_Notification, rhs: Patrol_Notification) -> Bool {
    if lhs.appName != rhs.appName {return false}
    if lhs.title != rhs.title {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_NotificationsQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotificationsQueryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notifications"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.notifications) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.notifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notifications, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Patrol_NotificationsQueryResponse, rhs: Patrol_NotificationsQueryResponse) -> Bool {
    if lhs.notifications != rhs.notifications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_NativeWidgetsQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NativeWidgetsQueryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nativeWidgets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nativeWidgets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nativeWidgets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nativeWidgets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Patrol_NativeWidgetsQueryResponse, rhs: Patrol_NativeWidgetsQueryResponse) -> Bool {
    if lhs.nativeWidgets != rhs.nativeWidgets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
