// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: contracts.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Patrol_ConfigureRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var findTimeoutMillis: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Patrol_OpenAppRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var appID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Patrol_TapOnNotificationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var findBy: Patrol_TapOnNotificationRequest.OneOf_FindBy? = nil

  public var index: UInt32 {
    get {
      if case .index(let v)? = findBy {return v}
      return 0
    }
    set {findBy = .index(newValue)}
  }

  public var selector: Patrol_Selector {
    get {
      if case .selector(let v)? = findBy {return v}
      return Patrol_Selector()
    }
    set {findBy = .selector(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_FindBy: Equatable {
    case index(UInt32)
    case selector(Patrol_Selector)

  #if !swift(>=4.1)
    public static func ==(lhs: Patrol_TapOnNotificationRequest.OneOf_FindBy, rhs: Patrol_TapOnNotificationRequest.OneOf_FindBy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.index, .index): return {
        guard case .index(let l) = lhs, case .index(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.selector, .selector): return {
        guard case .selector(let l) = lhs, case .selector(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// We're defining our own Empty instead of using google.protobuf.Empty because
/// the Dart plugin can't easily generate it.
///
/// See:
///  * https://github.com/google/protobuf.dart/issues/170
public struct Patrol_Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Patrol_OpenQuickSettingsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Patrol_DarkModeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var appID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Patrol_GetNativeViewsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var selector: Patrol_Selector {
    get {return _selector ?? Patrol_Selector()}
    set {_selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  public var hasSelector: Bool {return self._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  public mutating func clearSelector() {self._selector = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _selector: Patrol_Selector? = nil
}

public struct Patrol_GetNativeViewsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nativeViews: [Patrol_NativeView] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Patrol_GetNotificationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Patrol_GetNotificationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var notifications: [Patrol_Notification] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Patrol_TapRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var selector: Patrol_Selector {
    get {return _selector ?? Patrol_Selector()}
    set {_selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  public var hasSelector: Bool {return self._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  public mutating func clearSelector() {self._selector = nil}

  public var appID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _selector: Patrol_Selector? = nil
}

public struct Patrol_EnterTextRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: String = String()

  public var appID: String = String()

  public var findBy: Patrol_EnterTextRequest.OneOf_FindBy? = nil

  public var index: UInt32 {
    get {
      if case .index(let v)? = findBy {return v}
      return 0
    }
    set {findBy = .index(newValue)}
  }

  public var selector: Patrol_Selector {
    get {
      if case .selector(let v)? = findBy {return v}
      return Patrol_Selector()
    }
    set {findBy = .selector(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_FindBy: Equatable {
    case index(UInt32)
    case selector(Patrol_Selector)

  #if !swift(>=4.1)
    public static func ==(lhs: Patrol_EnterTextRequest.OneOf_FindBy, rhs: Patrol_EnterTextRequest.OneOf_FindBy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.index, .index): return {
        guard case .index(let l) = lhs, case .index(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.selector, .selector): return {
        guard case .selector(let l) = lhs, case .selector(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Patrol_SwipeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startX: Float = 0

  public var startY: Float = 0

  public var endX: Float = 0

  public var endY: Float = 0

  public var steps: UInt32 = 0

  public var appID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Patrol_HandlePermissionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Patrol_HandlePermissionRequest.Code = .whileUsing

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case whileUsing // = 0
    case onlyThisTime // = 1
    case denied // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .whileUsing
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .whileUsing
      case 1: self = .onlyThisTime
      case 2: self = .denied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .whileUsing: return 0
      case .onlyThisTime: return 1
      case .denied: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Patrol_HandlePermissionRequest.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Patrol_HandlePermissionRequest.Code] = [
    .whileUsing,
    .onlyThisTime,
    .denied,
  ]
}

#endif  // swift(>=4.2)

public struct Patrol_SetLocationAccuracyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var locationAccuracy: Patrol_SetLocationAccuracyRequest.LocationAccuracy = .coarse

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum LocationAccuracy: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case coarse // = 0
    case fine // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .coarse
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .coarse
      case 1: self = .fine
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .coarse: return 0
      case .fine: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Patrol_SetLocationAccuracyRequest.LocationAccuracy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Patrol_SetLocationAccuracyRequest.LocationAccuracy] = [
    .coarse,
    .fine,
  ]
}

#endif  // swift(>=4.2)

public struct Patrol_PermissionDialogVisibleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timeoutMillis: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Patrol_PermissionDialogVisibleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var visible: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Patrol_Selector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {self._text = nil}

  public var textStartsWith: String {
    get {return _textStartsWith ?? String()}
    set {_textStartsWith = newValue}
  }
  /// Returns true if `textStartsWith` has been explicitly set.
  public var hasTextStartsWith: Bool {return self._textStartsWith != nil}
  /// Clears the value of `textStartsWith`. Subsequent reads from it will return its default value.
  public mutating func clearTextStartsWith() {self._textStartsWith = nil}

  public var textContains: String {
    get {return _textContains ?? String()}
    set {_textContains = newValue}
  }
  /// Returns true if `textContains` has been explicitly set.
  public var hasTextContains: Bool {return self._textContains != nil}
  /// Clears the value of `textContains`. Subsequent reads from it will return its default value.
  public mutating func clearTextContains() {self._textContains = nil}

  public var className: String {
    get {return _className ?? String()}
    set {_className = newValue}
  }
  /// Returns true if `className` has been explicitly set.
  public var hasClassName: Bool {return self._className != nil}
  /// Clears the value of `className`. Subsequent reads from it will return its default value.
  public mutating func clearClassName() {self._className = nil}

  public var contentDescription: String {
    get {return _contentDescription ?? String()}
    set {_contentDescription = newValue}
  }
  /// Returns true if `contentDescription` has been explicitly set.
  public var hasContentDescription: Bool {return self._contentDescription != nil}
  /// Clears the value of `contentDescription`. Subsequent reads from it will return its default value.
  public mutating func clearContentDescription() {self._contentDescription = nil}

  public var contentDescriptionStartsWith: String {
    get {return _contentDescriptionStartsWith ?? String()}
    set {_contentDescriptionStartsWith = newValue}
  }
  /// Returns true if `contentDescriptionStartsWith` has been explicitly set.
  public var hasContentDescriptionStartsWith: Bool {return self._contentDescriptionStartsWith != nil}
  /// Clears the value of `contentDescriptionStartsWith`. Subsequent reads from it will return its default value.
  public mutating func clearContentDescriptionStartsWith() {self._contentDescriptionStartsWith = nil}

  public var contentDescriptionContains: String {
    get {return _contentDescriptionContains ?? String()}
    set {_contentDescriptionContains = newValue}
  }
  /// Returns true if `contentDescriptionContains` has been explicitly set.
  public var hasContentDescriptionContains: Bool {return self._contentDescriptionContains != nil}
  /// Clears the value of `contentDescriptionContains`. Subsequent reads from it will return its default value.
  public mutating func clearContentDescriptionContains() {self._contentDescriptionContains = nil}

  public var resourceID: String {
    get {return _resourceID ?? String()}
    set {_resourceID = newValue}
  }
  /// Returns true if `resourceID` has been explicitly set.
  public var hasResourceID: Bool {return self._resourceID != nil}
  /// Clears the value of `resourceID`. Subsequent reads from it will return its default value.
  public mutating func clearResourceID() {self._resourceID = nil}

  public var instance: UInt32 {
    get {return _instance ?? 0}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var enabled: Bool {
    get {return _enabled ?? false}
    set {_enabled = newValue}
  }
  /// Returns true if `enabled` has been explicitly set.
  public var hasEnabled: Bool {return self._enabled != nil}
  /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
  public mutating func clearEnabled() {self._enabled = nil}

  public var focused: Bool {
    get {return _focused ?? false}
    set {_focused = newValue}
  }
  /// Returns true if `focused` has been explicitly set.
  public var hasFocused: Bool {return self._focused != nil}
  /// Clears the value of `focused`. Subsequent reads from it will return its default value.
  public mutating func clearFocused() {self._focused = nil}

  public var pkg: String {
    get {return _pkg ?? String()}
    set {_pkg = newValue}
  }
  /// Returns true if `pkg` has been explicitly set.
  public var hasPkg: Bool {return self._pkg != nil}
  /// Clears the value of `pkg`. Subsequent reads from it will return its default value.
  public mutating func clearPkg() {self._pkg = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _text: String? = nil
  fileprivate var _textStartsWith: String? = nil
  fileprivate var _textContains: String? = nil
  fileprivate var _className: String? = nil
  fileprivate var _contentDescription: String? = nil
  fileprivate var _contentDescriptionStartsWith: String? = nil
  fileprivate var _contentDescriptionContains: String? = nil
  fileprivate var _resourceID: String? = nil
  fileprivate var _instance: UInt32? = nil
  fileprivate var _enabled: Bool? = nil
  fileprivate var _focused: Bool? = nil
  fileprivate var _pkg: String? = nil
}

/// Represents a native UI control.
///
/// On Android, this is `android.view.View`.
public struct Patrol_NativeView {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var className: String = String()

  public var text: String = String()

  public var contentDescription: String = String()

  public var focused: Bool = false

  public var enabled: Bool = false

  public var childCount: Int32 = 0

  public var resourceName: String = String()

  public var applicationPackage: String = String()

  public var children: [Patrol_NativeView] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a notification visible in the notification shade.
public struct Patrol_Notification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var appName: String {
    get {return _appName ?? String()}
    set {_appName = newValue}
  }
  /// Returns true if `appName` has been explicitly set.
  public var hasAppName: Bool {return self._appName != nil}
  /// Clears the value of `appName`. Subsequent reads from it will return its default value.
  public mutating func clearAppName() {self._appName = nil}

  public var title: String = String()

  public var content: String = String()

  public var raw: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _appName: String? = nil
}

public struct Patrol_SubmitTestResultsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var results: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Patrol_ConfigureRequest: @unchecked Sendable {}
extension Patrol_OpenAppRequest: @unchecked Sendable {}
extension Patrol_TapOnNotificationRequest: @unchecked Sendable {}
extension Patrol_TapOnNotificationRequest.OneOf_FindBy: @unchecked Sendable {}
extension Patrol_Empty: @unchecked Sendable {}
extension Patrol_OpenQuickSettingsRequest: @unchecked Sendable {}
extension Patrol_DarkModeRequest: @unchecked Sendable {}
extension Patrol_GetNativeViewsRequest: @unchecked Sendable {}
extension Patrol_GetNativeViewsResponse: @unchecked Sendable {}
extension Patrol_GetNotificationsRequest: @unchecked Sendable {}
extension Patrol_GetNotificationsResponse: @unchecked Sendable {}
extension Patrol_TapRequest: @unchecked Sendable {}
extension Patrol_EnterTextRequest: @unchecked Sendable {}
extension Patrol_EnterTextRequest.OneOf_FindBy: @unchecked Sendable {}
extension Patrol_SwipeRequest: @unchecked Sendable {}
extension Patrol_HandlePermissionRequest: @unchecked Sendable {}
extension Patrol_HandlePermissionRequest.Code: @unchecked Sendable {}
extension Patrol_SetLocationAccuracyRequest: @unchecked Sendable {}
extension Patrol_SetLocationAccuracyRequest.LocationAccuracy: @unchecked Sendable {}
extension Patrol_PermissionDialogVisibleRequest: @unchecked Sendable {}
extension Patrol_PermissionDialogVisibleResponse: @unchecked Sendable {}
extension Patrol_Selector: @unchecked Sendable {}
extension Patrol_NativeView: @unchecked Sendable {}
extension Patrol_Notification: @unchecked Sendable {}
extension Patrol_SubmitTestResultsRequest: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "patrol"

extension Patrol_ConfigureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfigureRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "findTimeoutMillis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.findTimeoutMillis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.findTimeoutMillis != 0 {
      try visitor.visitSingularUInt64Field(value: self.findTimeoutMillis, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_ConfigureRequest, rhs: Patrol_ConfigureRequest) -> Bool {
    if lhs.findTimeoutMillis != rhs.findTimeoutMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_OpenAppRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenAppRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_OpenAppRequest, rhs: Patrol_OpenAppRequest) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_TapOnNotificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TapOnNotificationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "selector"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.findBy != nil {try decoder.handleConflictingOneOf()}
          self.findBy = .index(v)
        }
      }()
      case 2: try {
        var v: Patrol_Selector?
        var hadOneofValue = false
        if let current = self.findBy {
          hadOneofValue = true
          if case .selector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.findBy = .selector(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.findBy {
    case .index?: try {
      guard case .index(let v)? = self.findBy else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }()
    case .selector?: try {
      guard case .selector(let v)? = self.findBy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_TapOnNotificationRequest, rhs: Patrol_TapOnNotificationRequest) -> Bool {
    if lhs.findBy != rhs.findBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Empty"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_Empty, rhs: Patrol_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_OpenQuickSettingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenQuickSettingsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_OpenQuickSettingsRequest, rhs: Patrol_OpenQuickSettingsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_DarkModeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DarkModeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_DarkModeRequest, rhs: Patrol_DarkModeRequest) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_GetNativeViewsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNativeViewsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "selector"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._selector) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._selector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_GetNativeViewsRequest, rhs: Patrol_GetNativeViewsRequest) -> Bool {
    if lhs._selector != rhs._selector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_GetNativeViewsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNativeViewsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "nativeViews"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.nativeViews) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nativeViews.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nativeViews, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_GetNativeViewsResponse, rhs: Patrol_GetNativeViewsResponse) -> Bool {
    if lhs.nativeViews != rhs.nativeViews {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_GetNotificationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNotificationsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_GetNotificationsRequest, rhs: Patrol_GetNotificationsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_GetNotificationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNotificationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "notifications"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.notifications) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.notifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notifications, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_GetNotificationsResponse, rhs: Patrol_GetNotificationsResponse) -> Bool {
    if lhs.notifications != rhs.notifications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_TapRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TapRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "selector"),
    2: .same(proto: "appId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._selector) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._selector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_TapRequest, rhs: Patrol_TapRequest) -> Bool {
    if lhs._selector != rhs._selector {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_EnterTextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnterTextRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "appId"),
    3: .same(proto: "index"),
    4: .same(proto: "selector"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 3: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.findBy != nil {try decoder.handleConflictingOneOf()}
          self.findBy = .index(v)
        }
      }()
      case 4: try {
        var v: Patrol_Selector?
        var hadOneofValue = false
        if let current = self.findBy {
          hadOneofValue = true
          if case .selector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.findBy = .selector(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 1)
    }
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 2)
    }
    switch self.findBy {
    case .index?: try {
      guard case .index(let v)? = self.findBy else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }()
    case .selector?: try {
      guard case .selector(let v)? = self.findBy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_EnterTextRequest, rhs: Patrol_EnterTextRequest) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.findBy != rhs.findBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_SwipeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwipeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startX"),
    2: .same(proto: "startY"),
    3: .same(proto: "endX"),
    4: .same(proto: "endY"),
    5: .same(proto: "steps"),
    6: .same(proto: "appId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.startX) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.startY) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.endX) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.endY) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.steps) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startX != 0 {
      try visitor.visitSingularFloatField(value: self.startX, fieldNumber: 1)
    }
    if self.startY != 0 {
      try visitor.visitSingularFloatField(value: self.startY, fieldNumber: 2)
    }
    if self.endX != 0 {
      try visitor.visitSingularFloatField(value: self.endX, fieldNumber: 3)
    }
    if self.endY != 0 {
      try visitor.visitSingularFloatField(value: self.endY, fieldNumber: 4)
    }
    if self.steps != 0 {
      try visitor.visitSingularUInt32Field(value: self.steps, fieldNumber: 5)
    }
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_SwipeRequest, rhs: Patrol_SwipeRequest) -> Bool {
    if lhs.startX != rhs.startX {return false}
    if lhs.startY != rhs.startY {return false}
    if lhs.endX != rhs.endX {return false}
    if lhs.endY != rhs.endY {return false}
    if lhs.steps != rhs.steps {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_HandlePermissionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HandlePermissionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .whileUsing {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_HandlePermissionRequest, rhs: Patrol_HandlePermissionRequest) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_HandlePermissionRequest.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WHILE_USING"),
    1: .same(proto: "ONLY_THIS_TIME"),
    2: .same(proto: "DENIED"),
  ]
}

extension Patrol_SetLocationAccuracyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetLocationAccuracyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locationAccuracy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.locationAccuracy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.locationAccuracy != .coarse {
      try visitor.visitSingularEnumField(value: self.locationAccuracy, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_SetLocationAccuracyRequest, rhs: Patrol_SetLocationAccuracyRequest) -> Bool {
    if lhs.locationAccuracy != rhs.locationAccuracy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_SetLocationAccuracyRequest.LocationAccuracy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COARSE"),
    1: .same(proto: "FINE"),
  ]
}

extension Patrol_PermissionDialogVisibleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PermissionDialogVisibleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timeoutMillis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.timeoutMillis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeoutMillis != 0 {
      try visitor.visitSingularUInt64Field(value: self.timeoutMillis, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_PermissionDialogVisibleRequest, rhs: Patrol_PermissionDialogVisibleRequest) -> Bool {
    if lhs.timeoutMillis != rhs.timeoutMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_PermissionDialogVisibleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PermissionDialogVisibleResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visible"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.visible) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.visible != false {
      try visitor.visitSingularBoolField(value: self.visible, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_PermissionDialogVisibleResponse, rhs: Patrol_PermissionDialogVisibleResponse) -> Bool {
    if lhs.visible != rhs.visible {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_Selector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Selector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "textStartsWith"),
    3: .same(proto: "textContains"),
    4: .same(proto: "className"),
    5: .same(proto: "contentDescription"),
    6: .same(proto: "contentDescriptionStartsWith"),
    7: .same(proto: "contentDescriptionContains"),
    8: .same(proto: "resourceId"),
    9: .same(proto: "instance"),
    10: .same(proto: "enabled"),
    11: .same(proto: "focused"),
    12: .same(proto: "pkg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._textStartsWith) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._textContains) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._className) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._contentDescription) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._contentDescriptionStartsWith) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._contentDescriptionContains) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._resourceID) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._instance) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._enabled) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self._focused) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._pkg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._textStartsWith {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._textContains {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._className {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._contentDescription {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._contentDescriptionStartsWith {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._contentDescriptionContains {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._resourceID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._enabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._focused {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._pkg {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_Selector, rhs: Patrol_Selector) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs._textStartsWith != rhs._textStartsWith {return false}
    if lhs._textContains != rhs._textContains {return false}
    if lhs._className != rhs._className {return false}
    if lhs._contentDescription != rhs._contentDescription {return false}
    if lhs._contentDescriptionStartsWith != rhs._contentDescriptionStartsWith {return false}
    if lhs._contentDescriptionContains != rhs._contentDescriptionContains {return false}
    if lhs._resourceID != rhs._resourceID {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs._enabled != rhs._enabled {return false}
    if lhs._focused != rhs._focused {return false}
    if lhs._pkg != rhs._pkg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_NativeView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NativeView"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "className"),
    2: .same(proto: "text"),
    3: .same(proto: "contentDescription"),
    4: .same(proto: "focused"),
    5: .same(proto: "enabled"),
    6: .same(proto: "childCount"),
    7: .same(proto: "resourceName"),
    8: .same(proto: "applicationPackage"),
    9: .same(proto: "children"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.className) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contentDescription) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.focused) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.childCount) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.resourceName) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.applicationPackage) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.children) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.className.isEmpty {
      try visitor.visitSingularStringField(value: self.className, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    if !self.contentDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.contentDescription, fieldNumber: 3)
    }
    if self.focused != false {
      try visitor.visitSingularBoolField(value: self.focused, fieldNumber: 4)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 5)
    }
    if self.childCount != 0 {
      try visitor.visitSingularInt32Field(value: self.childCount, fieldNumber: 6)
    }
    if !self.resourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceName, fieldNumber: 7)
    }
    if !self.applicationPackage.isEmpty {
      try visitor.visitSingularStringField(value: self.applicationPackage, fieldNumber: 8)
    }
    if !self.children.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.children, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_NativeView, rhs: Patrol_NativeView) -> Bool {
    if lhs.className != rhs.className {return false}
    if lhs.text != rhs.text {return false}
    if lhs.contentDescription != rhs.contentDescription {return false}
    if lhs.focused != rhs.focused {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.childCount != rhs.childCount {return false}
    if lhs.resourceName != rhs.resourceName {return false}
    if lhs.applicationPackage != rhs.applicationPackage {return false}
    if lhs.children != rhs.children {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_Notification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Notification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appName"),
    2: .same(proto: "title"),
    3: .same(proto: "content"),
    4: .same(proto: "raw"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._appName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.raw) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._appName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    if !self.raw.isEmpty {
      try visitor.visitSingularStringField(value: self.raw, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_Notification, rhs: Patrol_Notification) -> Bool {
    if lhs._appName != rhs._appName {return false}
    if lhs.title != rhs.title {return false}
    if lhs.content != rhs.content {return false}
    if lhs.raw != rhs.raw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Patrol_SubmitTestResultsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubmitTestResultsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.results) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.results, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Patrol_SubmitTestResultsRequest, rhs: Patrol_SubmitTestResultsRequest) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
