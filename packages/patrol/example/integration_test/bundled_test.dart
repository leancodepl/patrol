// ignore_for_file: invalid_use_of_internal_member,
// depend_on_referenced_packages

import 'dart:async';

import 'package:patrol/src/native/contracts/contracts.pbgrpc.dart';
import 'package:test_api/src/backend/group.dart';
import 'package:test_api/src/backend/group_entry.dart';
import 'package:test_api/src/backend/invoker.dart';
import 'package:test_api/src/backend/test.dart';

import 'common.dart';
import 'example_test.dart' as example_test;
import 'permissions/permissions_location_test.dart'
    as permissions_location_test;
import 'permissions/permissions_many_test.dart' as permissions_many_test;

// This whole file will be autogenerated.

Future<void> main() async {
  // TODO: Create and use PatrolNativeTestService instead of NativeAutomator
  final nativeAutomator = NativeAutomator(config: NativeAutomatorConfig());
  final binding = PatrolBinding.ensureInitialized();
  // Create a PatrolAppService.
  //
  // Android Test Orchestrator, before running the tests, makes an initial run
  // to gather the tests that it will later run. The native side of Patrol
  // (specifically: PatrolJUnitRunner class) is hooked into the Android Test
  // Orchestrator lifecycle and knows when that initial run happens. When it
  // does, PatrolJUnitRunner makes an RPC call to PatrolAppService and asks it
  // for the list of Dart tests.
  //
  // These Dart tests are later called by the single JUnit test that is
  // parametrized with the gathered Dart tests.

  final testDeclarationCompleter = Completer<DartTestGroup>();

  // Run a single, special test to expore the hierarchy of groups and tests
  test('patrol_test_explorer', () {
    final topLevelGroup = Invoker.current!.liveTest.groups.first;
    // print('Dart test suite hierarchy:');
    // _printGroupEntry(topLevelGroup);

    final dartTestGroup = createDartTestGroup(topLevelGroup);
    // print('DartTestGroup (from contracts):');
    //describe(dartTestGroup);

    testDeclarationCompleter.complete(dartTestGroup);
  });

  // START: GENERATED CODE
  group('permissions', () {
    group('permissions_location_test.dart', permissions_location_test.main);
    group('permissions_many_test.dart', permissions_many_test.main);
  });
  group('example_test.dart', example_test.main);
  // END: GENERATED CODE

  final dartTestGroup = await testDeclarationCompleter.future;
  final appService = createAppService(testGroup: dartTestGroup);
  binding.patrolAppService = appService;
  unawaited(runAppService(appService));

  // Until now, the PatrolJUnit runner was waiting for us (the Dart side) to
  // come alive. Now that we did, let's share this information with it.
  await nativeAutomator.markAppReady();
}

/// Prints test entry.
///
/// If [entry] is a group, then it's recursively printed as well.
void _printGroupEntry(GroupEntry entry, {int level = 0}) {
  final padding = '  ' * level;
  if (entry is Group) {
    print('$padding Group: ${entry.name}');
    for (final groupEntry in entry.entries) {
      _printGroupEntry(groupEntry, level: level + 1);
    }
  } else if (entry is Test) {
    if (entry.name == 'patrol_test_explorer') {
      return;
    }

    print('$padding Test: ${entry.name}');
  }
}

/// Recursively prints test groups and test cases.
///
/// [entry] is either a [DartTestGroup] or DartTestCase.
void describe(DartTestGroup entry, {int level = 0}) {
  final padding = '  ' * level;
  print(
    '$padding Group: ${entry.name} (${entry.groups.length} groups, ${entry.tests.length} tests)',
  );
  print('$padding  Groups: ${entry.groups.isEmpty ? 'none' : ''}');
  for (final groupEntry in entry.groups) {
    describe(groupEntry, level: level + 1);
  }
  print('$padding  Tests: ${entry.tests.isEmpty ? 'none' : ''}');
  for (final test in entry.tests) {
    print('$padding    Test: ${test.name}');
  }
}
