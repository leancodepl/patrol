{"version":3,"sources":["../lib/v4/isZodErrorLike.ts","../lib/v4/ValidationError.ts","../lib/v4/isValidationError.ts","../lib/v4/isValidationErrorLike.ts","../lib/v4/errorMap/custom.ts","../lib/v4/errorMap/invalidElement.ts","../lib/v4/errorMap/invalidKey.ts","../lib/v4/errorMap/invalidStringFormat.ts","../lib/v4/errorMap/invalidType.ts","../lib/v4/errorMap/invalidUnion.ts","../lib/utils/stringify.ts","../lib/utils/joinValues.ts","../lib/v4/errorMap/invalidValue.ts","../lib/v4/errorMap/notMultipleOf.ts","../lib/v4/errorMap/tooBig.ts","../lib/v4/errorMap/tooSmall.ts","../lib/v4/errorMap/unrecognizedKeys.ts","../lib/v4/errorMap/errorMap.ts","../lib/utils/NonEmptyArray.ts","../lib/utils/joinPath.ts","../lib/utils/titleCase.ts","../lib/v4/MessageBuilder.ts","../lib/v4/fromZodError.ts","../lib/v4/toValidationError.ts","../lib/v4/fromError.ts","../lib/v4/fromZodIssue.ts"],"sourcesContent":["import type * as zod from 'zod/v4/core';\n\nexport function isZodErrorLike(err: unknown): err is zod.$ZodError {\n  return (\n    err instanceof Object &&\n    'name' in err &&\n    (err.name === 'ZodError' || err.name === '$ZodError') &&\n    'issues' in err &&\n    Array.isArray(err.issues)\n  );\n}\n","import { isZodErrorLike } from './isZodErrorLike.ts';\nimport type * as zod from 'zod/v4/core';\n\nexport const ZOD_VALIDATION_ERROR_NAME = 'ZodValidationError';\n\n// make zod-validation-error compatible with\n// earlier to es2022 typescript configurations\n// @see https://github.com/causaly/zod-validation-error/issues/226\nexport interface ErrorOptions {\n  cause?: unknown;\n}\n\nexport class ValidationError extends Error {\n  name: typeof ZOD_VALIDATION_ERROR_NAME;\n  details: Array<zod.$ZodIssue>;\n\n  constructor(message?: string, options?: ErrorOptions) {\n    super(message, options);\n    this.name = ZOD_VALIDATION_ERROR_NAME;\n    this.details = getIssuesFromErrorOptions(options);\n  }\n\n  toString(): string {\n    return this.message;\n  }\n}\n\nfunction getIssuesFromErrorOptions(\n  options?: ErrorOptions\n): Array<zod.$ZodIssue> {\n  if (options) {\n    const cause = options.cause;\n    if (isZodErrorLike(cause)) {\n      return cause.issues;\n    }\n  }\n\n  return [];\n}\n","import { ValidationError } from './ValidationError.ts';\n\nexport function isValidationError(err: unknown): err is ValidationError {\n  return err instanceof ValidationError;\n}\n","import {\n  ZOD_VALIDATION_ERROR_NAME,\n  type ValidationError,\n} from './ValidationError.ts';\n\nexport function isValidationErrorLike(err: unknown): err is ValidationError {\n  return err instanceof Error && err.name === ZOD_VALIDATION_ERROR_NAME;\n}\n","import type * as zod from 'zod/v4/core';\nimport type { AbstractSyntaxTree } from './types.ts';\n\nexport function parseCustomIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueCustom>\n): AbstractSyntaxTree {\n  return {\n    type: issue.code,\n    path: issue.path,\n    message: issue.message ?? 'Invalid input',\n  };\n}\n","import type * as zod from 'zod/v4/core';\nimport type { AbstractSyntaxTree } from './types.ts';\n\nexport function parseInvalidElementIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueInvalidElement>\n): AbstractSyntaxTree {\n  return {\n    type: issue.code,\n    path: issue.path,\n    message: `unexpected element in ${issue.origin}`,\n  };\n}\n","import type * as zod from 'zod/v4/core';\nimport type { AbstractSyntaxTree } from './types.ts';\n\nexport function parseInvalidKeyIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueInvalidKey>\n): AbstractSyntaxTree {\n  return {\n    type: issue.code,\n    path: issue.path,\n    message: `unexpected key in ${issue.origin}`,\n  };\n}\n","import type { AbstractSyntaxTree, ErrorMapOptions } from './types.ts';\nimport type * as zod from 'zod/v4/core';\n\nexport function parseInvalidStringFormatIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueInvalidStringFormat>,\n  options: Pick<ErrorMapOptions, 'displayInvalidFormatDetails'> = {\n    displayInvalidFormatDetails: false,\n  }\n): AbstractSyntaxTree {\n  switch (issue.format) {\n    case 'lowercase':\n    case 'uppercase':\n      return {\n        type: issue.code,\n        path: issue.path,\n        message: `value must be in ${issue.format} format`,\n      };\n    default: {\n      if (isZodIssueStringStartsWith(issue)) {\n        return parseStringStartsWith(issue);\n      }\n      if (isZodIssueStringEndsWith(issue)) {\n        return parseStringEndsWith(issue);\n      }\n      if (isZodIssueStringIncludes(issue)) {\n        return parseStringIncludes(issue);\n      }\n      if (isZodIssueStringInvalidRegex(issue)) {\n        return parseStringInvalidRegex(issue, options);\n      }\n      if (isZodIssueStringInvalidJWT(issue)) {\n        return parseStringInvalidJWT(issue, options);\n      }\n\n      return {\n        type: issue.code,\n        path: issue.path,\n        message: `invalid ${issue.format}`,\n      };\n    }\n  }\n}\nfunction isZodIssueStringStartsWith(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueInvalidStringFormat>\n): issue is zod.$ZodRawIssue<zod.$ZodIssueStringStartsWith> {\n  return issue.format === 'starts_with';\n}\n\nfunction parseStringStartsWith(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueStringStartsWith>\n): AbstractSyntaxTree {\n  return {\n    type: issue.code,\n    path: issue.path,\n    message: `value must start with \"${issue.prefix}\"`,\n  };\n}\n\nfunction isZodIssueStringEndsWith(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueInvalidStringFormat>\n): issue is zod.$ZodRawIssue<zod.$ZodIssueStringEndsWith> {\n  return issue.format === 'ends_with';\n}\nfunction parseStringEndsWith(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueStringEndsWith>\n): AbstractSyntaxTree {\n  return {\n    type: issue.code,\n    path: issue.path,\n    message: `value must end with \"${issue.suffix}\"`,\n  };\n}\n\nfunction isZodIssueStringIncludes(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueInvalidStringFormat>\n): issue is zod.$ZodRawIssue<zod.$ZodIssueStringIncludes> {\n  return issue.format === 'includes';\n}\nfunction parseStringIncludes(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueStringIncludes>\n): AbstractSyntaxTree {\n  return {\n    type: issue.code,\n    path: issue.path,\n    message: `value must include \"${issue.includes}\"`,\n  };\n}\n\nfunction isZodIssueStringInvalidRegex(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueInvalidStringFormat>\n): issue is zod.$ZodRawIssue<zod.$ZodIssueStringInvalidRegex> {\n  return issue.format === 'regex';\n}\nfunction parseStringInvalidRegex(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueStringInvalidRegex>,\n  options: Pick<ErrorMapOptions, 'displayInvalidFormatDetails'> = {\n    displayInvalidFormatDetails: false,\n  }\n): AbstractSyntaxTree {\n  let message = 'value must match pattern';\n  if (options.displayInvalidFormatDetails) {\n    message += ` \"${issue.pattern}\"`;\n  }\n\n  return {\n    type: issue.code,\n    path: issue.path,\n    message,\n  };\n}\n\nfunction isZodIssueStringInvalidJWT(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueInvalidStringFormat>\n): issue is zod.$ZodRawIssue<zod.$ZodIssueStringInvalidJWT> {\n  return issue.format === 'jwt';\n}\nfunction parseStringInvalidJWT(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueStringInvalidJWT>,\n  options: Pick<ErrorMapOptions, 'displayInvalidFormatDetails'> = {\n    displayInvalidFormatDetails: false,\n  }\n): AbstractSyntaxTree {\n  return {\n    type: issue.code,\n    path: issue.path,\n    message:\n      options.displayInvalidFormatDetails && issue.algorithm\n        ? `invalid jwt/${issue.algorithm}`\n        : `invalid jwt`,\n  };\n}\n","import type { AbstractSyntaxTree } from './types.ts';\nimport type * as zod from 'zod/v4/core';\n\nexport function parseInvalidTypeIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueInvalidType>\n): AbstractSyntaxTree {\n  let message = `expected ${issue.expected}`;\n\n  // note: it's possible that issue.input is not defined\n  if ('input' in issue) {\n    message += `, received ${getTypeName(issue.input)}`;\n  }\n\n  return {\n    type: issue.code,\n    path: issue.path,\n    message,\n  };\n}\n\nexport function getTypeName(value: unknown): string {\n  if (typeof value === 'object') {\n    if (value === null) {\n      return 'null';\n    }\n    if (value === undefined) {\n      return 'undefined';\n    }\n    if (Array.isArray(value)) {\n      return 'array';\n    }\n    if (value instanceof Date) {\n      return 'date';\n    }\n    if (value instanceof RegExp) {\n      return 'regexp';\n    }\n    if (value instanceof Map) {\n      return 'map';\n    }\n    if (value instanceof Set) {\n      return 'set';\n    }\n    if (value instanceof Error) {\n      return 'error';\n    }\n    if (value instanceof Function) {\n      return 'function';\n    }\n    return 'object';\n  }\n\n  return typeof value;\n}\n","import type * as zod from 'zod/v4/core';\nimport type { AbstractSyntaxTree } from './types.ts';\n\nexport function parseInvalidUnionIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueInvalidUnion>\n): AbstractSyntaxTree {\n  return {\n    type: issue.code,\n    path: issue.path,\n    message: issue.message ?? 'Invalid input',\n  };\n}\n","import type { util } from 'zod/v4/core';\n\nexport function stringifySymbol(symbol: symbol): string {\n  return symbol.description ?? '';\n}\n\nexport type StringifyValueOptions = {\n  wrapStringValueInQuote?: boolean;\n  localization?: boolean | Intl.LocalesArgument;\n};\n\nexport function stringify(\n  value: util.Primitive | Date,\n  options: StringifyValueOptions = {}\n): string {\n  switch (typeof value) {\n    case 'symbol':\n      return stringifySymbol(value);\n    case 'bigint':\n    case 'number': {\n      switch (options.localization) {\n        case true:\n          return value.toLocaleString();\n        case false:\n          return value.toString();\n        default:\n          return value.toLocaleString(options.localization);\n      }\n    }\n    case 'string': {\n      if (options.wrapStringValueInQuote) {\n        return `\"${value}\"`;\n      }\n      return value;\n    }\n    default: {\n      if (value instanceof Date) {\n        switch (options.localization) {\n          case true:\n            return value.toLocaleString();\n          case false:\n            return value.toISOString();\n          default:\n            return value.toLocaleString(options.localization);\n        }\n      }\n      return String(value);\n    }\n  }\n}\n","import { stringify } from './stringify.ts';\nimport type { util } from 'zod/v4/core';\n\nexport type JoinValuesOptions = {\n  separator: string;\n  lastSeparator?: string;\n  wrapStringValuesInQuote?: boolean;\n  maxValuesToDisplay?: number;\n};\n\nexport function joinValues(\n  values: Array<util.Primitive>,\n  options: JoinValuesOptions\n): string {\n  const valuesToDisplay = (\n    options.maxValuesToDisplay\n      ? values.slice(0, options.maxValuesToDisplay)\n      : values\n  ).map((value) => {\n    return stringify(value, {\n      wrapStringValueInQuote: options.wrapStringValuesInQuote,\n    });\n  });\n\n  // add remaining values count (if any)\n  // this is to avoid displaying too many values in the error message\n  // and to keep the message concise\n  // e.g. `\"foo\", \"bar\", \"baz\" or 3 more value(s)`\n  if (valuesToDisplay.length < values.length) {\n    valuesToDisplay.push(\n      `${values.length - valuesToDisplay.length} more value(s)`\n    );\n  }\n\n  return valuesToDisplay.reduce<string>((acc, value, index) => {\n    if (index > 0) {\n      if (index === valuesToDisplay.length - 1 && options.lastSeparator) {\n        acc += options.lastSeparator;\n      } else {\n        acc += options.separator;\n      }\n    }\n\n    acc += value;\n\n    return acc;\n  }, '');\n}\n","import { joinValues } from '../../utils/joinValues.ts';\nimport { stringify } from '../../utils/stringify.ts';\nimport type { AbstractSyntaxTree, ErrorMapOptions } from './types.ts';\nimport type * as zod from 'zod/v4/core';\n\nexport function parseInvalidValueIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueInvalidValue>,\n  options: Pick<\n    ErrorMapOptions,\n    | 'allowedValuesSeparator'\n    | 'maxAllowedValuesToDisplay'\n    | 'wrapAllowedValuesInQuote'\n    | 'allowedValuesLastSeparator'\n  >\n): AbstractSyntaxTree {\n  let message: string;\n\n  if (issue.values.length === 0) {\n    message = 'invalid value';\n  } else if (issue.values.length === 1) {\n    const valueStr = stringify(issue.values[0], {\n      wrapStringValueInQuote: true,\n    });\n    message = `expected value to be ${valueStr}`;\n  } else {\n    const valuesStr = joinValues(issue.values, {\n      separator: options.allowedValuesSeparator,\n      lastSeparator: options.allowedValuesLastSeparator,\n      wrapStringValuesInQuote: options.wrapAllowedValuesInQuote,\n      maxValuesToDisplay: options.maxAllowedValuesToDisplay,\n    });\n    message = `expected value to be one of ${valuesStr}`;\n  }\n\n  return {\n    type: issue.code,\n    path: issue.path,\n    message,\n  };\n}\n","import type * as zod from 'zod/v4/core';\nimport type { AbstractSyntaxTree } from './types.ts';\n\nexport function parseNotMultipleOfIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueNotMultipleOf>\n): AbstractSyntaxTree {\n  return {\n    type: issue.code,\n    path: issue.path,\n    message: `expected multiple of ${issue.divisor}`,\n  };\n}\n","import { stringify } from '../../utils/stringify.ts';\nimport type { AbstractSyntaxTree, ErrorMapOptions } from './types.ts';\nimport type * as zod from 'zod/v4/core';\n\nexport function parseTooBigIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueTooBig>,\n  options: Pick<ErrorMapOptions, 'dateLocalization' | 'numberLocalization'>\n): AbstractSyntaxTree {\n  const maxValueStr =\n    issue.origin === 'date'\n      ? stringify(new Date(issue.maximum as number), {\n          localization: options.dateLocalization,\n        })\n      : stringify(issue.maximum, {\n          localization: options.numberLocalization,\n        });\n\n  switch (issue.origin) {\n    case 'number':\n    case 'int':\n    case 'bigint': {\n      return {\n        type: issue.code,\n        path: issue.path,\n        message: `number must be less than${\n          issue.inclusive ? ' or equal to' : ''\n        } ${maxValueStr}`,\n      };\n    }\n    case 'string': {\n      return {\n        type: issue.code,\n        path: issue.path,\n        message: `string must contain at most ${maxValueStr} character(s)`,\n      };\n    }\n    case 'date': {\n      return {\n        type: issue.code,\n        path: issue.path,\n        message: `date must be ${\n          issue.inclusive ? 'prior or equal to' : 'prior to'\n        } \"${maxValueStr}\"`,\n      };\n    }\n    case 'array': {\n      return {\n        type: issue.code,\n        path: issue.path,\n        message: `array must contain at most ${maxValueStr} item(s)`,\n      };\n    }\n    case 'set': {\n      return {\n        type: issue.code,\n        path: issue.path,\n        message: `set must contain at most ${maxValueStr} item(s)`,\n      };\n    }\n    case 'file': {\n      return {\n        type: issue.code,\n        path: issue.path,\n        message: `file must not exceed ${maxValueStr} byte(s) in size`,\n      };\n    }\n    default:\n      return {\n        type: issue.code,\n        path: issue.path,\n        message: `value must be less than${\n          issue.inclusive ? ' or equal to' : ''\n        } ${maxValueStr}`,\n      };\n  }\n}\n","import { stringify } from '../../utils/stringify.ts';\nimport type * as zod from 'zod/v4/core';\nimport type { AbstractSyntaxTree, ErrorMapOptions } from './types.ts';\n\nexport function parseTooSmallIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueTooSmall>,\n  options: Pick<ErrorMapOptions, 'dateLocalization' | 'numberLocalization'>\n): AbstractSyntaxTree {\n  const minValueStr =\n    issue.origin === 'date'\n      ? stringify(new Date(issue.minimum as number), {\n          localization: options.dateLocalization,\n        })\n      : stringify(issue.minimum, {\n          localization: options.numberLocalization,\n        });\n\n  switch (issue.origin) {\n    case 'number':\n    case 'int':\n    case 'bigint': {\n      return {\n        type: issue.code,\n        path: issue.path,\n        message: `number must be greater than${\n          issue.inclusive ? ' or equal to' : ''\n        } ${minValueStr}`,\n      };\n    }\n    case 'date': {\n      return {\n        type: issue.code,\n        path: issue.path,\n        message: `date must be ${\n          issue.inclusive ? 'later or equal to' : 'later to'\n        } \"${minValueStr}\"`,\n      };\n    }\n    case 'string': {\n      return {\n        type: issue.code,\n        path: issue.path,\n        message: `string must contain at least ${minValueStr} character(s)`,\n      };\n    }\n    case 'array': {\n      return {\n        type: issue.code,\n        path: issue.path,\n        message: `array must contain at least ${minValueStr} item(s)`,\n      };\n    }\n    case 'set': {\n      return {\n        type: issue.code,\n        path: issue.path,\n        message: `set must contain at least ${minValueStr} item(s)`,\n      };\n    }\n    case 'file': {\n      return {\n        type: issue.code,\n        path: issue.path,\n        message: `file must be at least ${minValueStr} byte(s) in size`,\n      };\n    }\n    default:\n      return {\n        type: issue.code,\n        path: issue.path,\n        message: `value must be greater than${\n          issue.inclusive ? ' or equal to' : ''\n        } ${minValueStr}`,\n      };\n  }\n}\n","import { joinValues } from '../../utils/joinValues.ts';\nimport type * as zod from 'zod/v4/core';\nimport type { AbstractSyntaxTree, ErrorMapOptions } from './types.ts';\n\nexport function parseUnrecognizedKeysIssue(\n  issue: zod.$ZodRawIssue<zod.$ZodIssueUnrecognizedKeys>,\n  options: Pick<\n    ErrorMapOptions,\n    | 'unrecognizedKeysSeparator'\n    | 'unrecognizedKeysLastSeparator'\n    | 'wrapUnrecognizedKeysInQuote'\n    | 'maxUnrecognizedKeysToDisplay'\n  >\n): AbstractSyntaxTree {\n  const keysStr = joinValues(issue.keys, {\n    separator: options.unrecognizedKeysSeparator,\n    lastSeparator: options.unrecognizedKeysLastSeparator,\n    wrapStringValuesInQuote: options.wrapUnrecognizedKeysInQuote,\n    maxValuesToDisplay: options.maxUnrecognizedKeysToDisplay,\n  });\n\n  return {\n    type: issue.code,\n    path: issue.path,\n    message: `unrecognized key(s) ${keysStr} in object`,\n  };\n}\n","import { parseCustomIssue } from './custom.ts';\nimport { parseInvalidElementIssue } from './invalidElement.ts';\nimport { parseInvalidKeyIssue } from './invalidKey.ts';\nimport { parseInvalidStringFormatIssue } from './invalidStringFormat.ts';\nimport { parseInvalidTypeIssue } from './invalidType.ts';\nimport { parseInvalidUnionIssue } from './invalidUnion.ts';\nimport { parseInvalidValueIssue } from './invalidValue.ts';\nimport { parseNotMultipleOfIssue } from './notMultipleOf.ts';\nimport { parseTooBigIssue } from './tooBig.ts';\nimport { parseTooSmallIssue } from './tooSmall.ts';\nimport { parseUnrecognizedKeysIssue } from './unrecognizedKeys.ts';\nimport type {\n  AbstractSyntaxTree,\n  ErrorMapOptions,\n  IssueType,\n} from './types.ts';\nimport type * as zod from 'zod/v4/core';\n\ntype IssueParsers = {\n  [IssueCode in IssueType]: (\n    issue: zod.$ZodRawIssue<Extract<zod.$ZodIssue, { code: IssueCode }>>,\n    options: ErrorMapOptions\n  ) => AbstractSyntaxTree;\n};\n\nconst issueParsers: IssueParsers = {\n  invalid_type: parseInvalidTypeIssue,\n  too_big: parseTooBigIssue,\n  too_small: parseTooSmallIssue,\n  invalid_format: parseInvalidStringFormatIssue,\n  invalid_value: parseInvalidValueIssue,\n  invalid_element: parseInvalidElementIssue,\n  not_multiple_of: parseNotMultipleOfIssue,\n  unrecognized_keys: parseUnrecognizedKeysIssue,\n  invalid_key: parseInvalidKeyIssue,\n  custom: parseCustomIssue,\n  invalid_union: parseInvalidUnionIssue,\n};\n\nexport const defaultErrorMapOptions = {\n  displayInvalidFormatDetails: false,\n  allowedValuesSeparator: ', ',\n  allowedValuesLastSeparator: ' or ',\n  wrapAllowedValuesInQuote: true,\n  maxAllowedValuesToDisplay: 10,\n  unrecognizedKeysSeparator: ', ',\n  unrecognizedKeysLastSeparator: ' and ',\n  wrapUnrecognizedKeysInQuote: true,\n  maxUnrecognizedKeysToDisplay: 5,\n  dateLocalization: true,\n  numberLocalization: true,\n} as const satisfies ErrorMapOptions;\n\nexport function createErrorMap(\n  partialOptions: Partial<ErrorMapOptions> = {}\n): zod.$ZodErrorMap<zod.$ZodIssue> {\n  // fill-in default options\n  const options = {\n    ...defaultErrorMapOptions,\n    ...partialOptions,\n  };\n\n  const errorMap: zod.$ZodErrorMap<zod.$ZodIssue> = (issue) => {\n    if (issue.code === undefined) {\n      // TODO: handle this case\n      return 'Not supported issue type';\n    }\n\n    const parseFunc = issueParsers[issue.code] as (\n      iss: typeof issue,\n      opts: ErrorMapOptions\n    ) => AbstractSyntaxTree;\n    const ast = parseFunc(issue, options);\n    return ast.message;\n  };\n\n  return errorMap;\n}\n","export type NonEmptyArray<T> = [T, ...T[]];\n\nexport function isNonEmptyArray<T>(value: T[]): value is NonEmptyArray<T> {\n  return value.length !== 0;\n}\n","import { stringifySymbol } from './stringify.ts';\nimport type { NonEmptyArray } from './NonEmptyArray.ts';\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers\n */\nconst identifierRegex = /[$_\\p{ID_Start}][$\\u200c\\u200d\\p{ID_Continue}]*/u;\n\nexport function joinPath(path: NonEmptyArray<PropertyKey>): string {\n  if (path.length === 1) {\n    let propertyKey = path[0];\n\n    if (typeof propertyKey === 'symbol') {\n      propertyKey = stringifySymbol(propertyKey);\n    }\n\n    return propertyKey.toString() || '\"\"';\n  }\n\n  return path.reduce<string>((acc, propertyKey) => {\n    // handle numeric indices\n    if (typeof propertyKey === 'number') {\n      return acc + '[' + propertyKey.toString() + ']';\n    }\n\n    // handle symbols\n    if (typeof propertyKey === 'symbol') {\n      propertyKey = stringifySymbol(propertyKey);\n    }\n\n    // handle quoted values\n    if (propertyKey.includes('\"')) {\n      return acc + '[\"' + escapeQuotes(propertyKey) + '\"]';\n    }\n\n    // handle special characters\n    if (!identifierRegex.test(propertyKey)) {\n      return acc + '[\"' + propertyKey + '\"]';\n    }\n\n    // handle normal values\n    const separator = acc.length === 0 ? '' : '.';\n    return acc + separator + propertyKey;\n  }, '');\n}\n\nfunction escapeQuotes(str: string): string {\n  return str.replace(/\"/g, '\\\\\"');\n}\n","export function titleCase(value: string): string {\n  if (value.length === 0) {\n    return value;\n  }\n  return value.charAt(0).toUpperCase() + value.slice(1);\n}\n","import { joinPath } from '../utils/joinPath.ts';\nimport { isNonEmptyArray, type NonEmptyArray } from '../utils/NonEmptyArray.ts';\nimport { titleCase } from '../utils/titleCase.ts';\nimport type * as zod from 'zod/v4/core';\n\nexport type ZodIssue = zod.$ZodIssue;\n\nexport type MessageBuilder = (issues: NonEmptyArray<ZodIssue>) => string;\n\nexport type MessageBuilderOptions = {\n  prefix: string | null | undefined;\n  prefixSeparator: string;\n  maxIssuesInMessage: number;\n  issueSeparator: string;\n  unionSeparator: string;\n  includePath: boolean;\n  forceTitleCase: boolean;\n};\n\nexport const defaultMessageBuilderOptions: MessageBuilderOptions & {\n  prefix: string;\n} = {\n  prefix: 'Validation error',\n  prefixSeparator: ': ',\n  maxIssuesInMessage: 99, // I've got 99 problems but the b$tch ain't one\n  unionSeparator: ' or ',\n  issueSeparator: '; ',\n  includePath: true,\n  forceTitleCase: true,\n};\n\nexport function createMessageBuilder(\n  partialOptions: Partial<MessageBuilderOptions> = {}\n): MessageBuilder {\n  const options = {\n    ...defaultMessageBuilderOptions,\n    ...partialOptions,\n  };\n\n  return function messageBuilder(issues) {\n    const message = issues\n      // limit max number of issues printed in the reason section\n      .slice(0, options.maxIssuesInMessage)\n      // format error message\n      .map((issue) => mapIssue(issue, options))\n      // concat as string\n      .join(options.issueSeparator);\n\n    return conditionallyPrefixMessage(message, options);\n  };\n}\n\nfunction mapIssue(\n  issue: zod.$ZodIssue,\n  options: MessageBuilderOptions\n): string {\n  if (issue.code === 'invalid_union' && isNonEmptyArray(issue.errors)) {\n    const individualMessages = issue.errors.map((issues) =>\n      issues\n        .map((subIssue) =>\n          mapIssue(\n            {\n              ...subIssue,\n              path: issue.path.concat(subIssue.path),\n            },\n            options\n          )\n        )\n        .join(options.issueSeparator)\n    );\n\n    // deduplicate messages\n    // and join them with the union separator\n    // to create a single message for the invalid union issue\n    return Array.from(new Set(individualMessages)).join(options.unionSeparator);\n  }\n\n  const buf = [];\n\n  if (options.forceTitleCase) {\n    buf.push(titleCase(issue.message));\n  } else {\n    buf.push(issue.message);\n  }\n\n  pathCondition: if (\n    options.includePath &&\n    issue.path !== undefined &&\n    isNonEmptyArray(issue.path)\n  ) {\n    // handle array indices\n    if (issue.path.length === 1) {\n      const identifier = issue.path[0];\n\n      if (typeof identifier === 'number') {\n        buf.push(` at index ${identifier}`);\n        break pathCondition;\n      }\n    }\n\n    buf.push(` at \"${joinPath(issue.path)}\"`);\n  }\n\n  return buf.join('');\n}\n\nfunction conditionallyPrefixMessage(\n  message: string,\n  options: Pick<MessageBuilderOptions, 'prefix' | 'prefixSeparator'>\n): string {\n  if (options.prefix != null) {\n    if (message.length > 0) {\n      return [options.prefix, message].join(options.prefixSeparator);\n    }\n\n    return options.prefix;\n  }\n\n  if (message.length > 0) {\n    return message;\n  }\n\n  // if both reason and prefix are empty, return default prefix\n  // to avoid having an empty error message\n  return defaultMessageBuilderOptions.prefix;\n}\n","import { isNonEmptyArray } from '../utils/NonEmptyArray.ts';\nimport { fromError } from './fromError.ts';\nimport { isZodErrorLike } from './isZodErrorLike.ts';\nimport {\n  createMessageBuilder,\n  type MessageBuilderOptions,\n  type MessageBuilder,\n} from './MessageBuilder.ts';\nimport { ValidationError } from './ValidationError.ts';\nimport type * as zod from 'zod/v4/core';\n\nexport type ZodError = zod.$ZodError;\n\nexport type FromZodErrorOptions =\n  | {\n      messageBuilder: MessageBuilder;\n    }\n  // maintain backwards compatibility\n  | Partial<MessageBuilderOptions>;\n\nexport function fromZodError(\n  zodError: ZodError,\n  options: FromZodErrorOptions = {}\n): ValidationError {\n  // perform runtime check to ensure the input is a ZodError\n  // why? because people have been historically using this function incorrectly\n  if (!isZodErrorLike(zodError)) {\n    throw new TypeError(\n      `Invalid zodError param; expected instance of ZodError. Did you mean to use the \"${fromError.name}\" method instead?`\n    );\n  }\n\n  return fromZodErrorWithoutRuntimeCheck(zodError, options);\n}\n\nexport function fromZodErrorWithoutRuntimeCheck(\n  zodError: ZodError,\n  options: FromZodErrorOptions = {}\n): ValidationError {\n  const zodIssues = zodError.issues;\n\n  let message: string;\n  if (isNonEmptyArray(zodIssues)) {\n    const messageBuilder = createMessageBuilderFromOptions(options);\n    message = messageBuilder(zodIssues);\n  } else {\n    message = zodError.message;\n  }\n\n  return new ValidationError(message, { cause: zodError });\n}\n\nfunction createMessageBuilderFromOptions(\n  options: FromZodErrorOptions\n): MessageBuilder {\n  if ('messageBuilder' in options) {\n    return options.messageBuilder;\n  }\n\n  return createMessageBuilder(options);\n}\n","import { ValidationError } from './ValidationError.ts';\nimport { isZodErrorLike } from './isZodErrorLike.ts';\nimport {\n  fromZodErrorWithoutRuntimeCheck,\n  type FromZodErrorOptions,\n} from './fromZodError.ts';\n\nexport const toValidationError =\n  (options: FromZodErrorOptions = {}) =>\n  (err: unknown): ValidationError => {\n    if (isZodErrorLike(err)) {\n      return fromZodErrorWithoutRuntimeCheck(err, options);\n    }\n\n    if (err instanceof Error) {\n      return new ValidationError(err.message, { cause: err });\n    }\n\n    return new ValidationError('Unknown error');\n  };\n","import { toValidationError } from './toValidationError.ts';\nimport type { FromZodErrorOptions } from './fromZodError.ts';\nimport type { ValidationError } from './ValidationError.ts';\n\n/**\n * This function is a non-curried version of `toValidationError`\n */\nexport function fromError(\n  err: unknown,\n  options: FromZodErrorOptions = {}\n): ValidationError {\n  return toValidationError(options)(err);\n}\n","import * as zod from 'zod/v4/core';\n\nimport {\n  type MessageBuilder,\n  type MessageBuilderOptions,\n  type ZodIssue,\n  createMessageBuilder,\n} from './MessageBuilder.ts';\nimport { ValidationError } from './ValidationError.ts';\n\nexport type FromZodIssueOptions =\n  | {\n      messageBuilder: MessageBuilder;\n    }\n  // maintain backwards compatibility\n  | Partial<Omit<MessageBuilderOptions, 'maxIssuesInMessage'>>;\n\nexport function fromZodIssue(\n  issue: ZodIssue,\n  options: FromZodIssueOptions = {}\n): ValidationError {\n  const messageBuilder = createMessageBuilderFromOptions(options);\n  const message = messageBuilder([issue]);\n\n  return new ValidationError(message, {\n    cause: new zod.$ZodRealError([issue]),\n  });\n}\n\nfunction createMessageBuilderFromOptions(\n  options: FromZodIssueOptions\n): MessageBuilder {\n  if ('messageBuilder' in options) {\n    return options.messageBuilder;\n  }\n\n  return createMessageBuilder(options);\n}\n"],"mappings":"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","names":["createMessageBuilderFromOptions"]}