import { NxJsonConfiguration } from '../config/nx-json';
import { ProjectConfiguration, ProjectMetadata, TargetConfiguration } from '../config/workspace-json-project-json';
import type { Tree } from '../generators/tree';
import { PackageManagerCommands } from './package-manager';
export interface NxProjectPackageJsonConfiguration extends Partial<ProjectConfiguration> {
    includedScripts?: string[];
}
export type ArrayPackageGroup = {
    package: string;
    version: string;
}[];
export type MixedPackageGroup = (string | {
    package: string;
    version: string;
})[] | Record<string, string>;
export type PackageGroup = MixedPackageGroup | ArrayPackageGroup;
export type PackageJsonDependencySection = 'dependencies' | 'devDependencies' | 'peerDependencies' | 'optionalDependencies';
export interface NxMigrationsConfiguration {
    migrations?: string;
    packageGroup?: PackageGroup;
}
type PackageOverride = {
    [key: string]: string | PackageOverride;
};
export interface PackageJson {
    name: string;
    version: string;
    license?: string;
    private?: boolean;
    scripts?: Record<string, string>;
    type?: 'module' | 'commonjs';
    main?: string;
    types?: string;
    typings?: string;
    module?: string;
    exports?: string | Record<string, string | {
        types?: string;
        require?: string;
        import?: string;
        development?: string;
        default?: string;
    }>;
    dependencies?: Record<string, string>;
    devDependencies?: Record<string, string>;
    optionalDependencies?: Record<string, string>;
    peerDependencies?: Record<string, string>;
    peerDependenciesMeta?: Record<string, {
        optional: boolean;
    }>;
    resolutions?: Record<string, string>;
    pnpm?: {
        overrides?: PackageOverride;
    };
    overrides?: PackageOverride;
    bin?: Record<string, string> | string;
    workspaces?: string[] | {
        packages: string[];
    };
    publishConfig?: Record<string, string>;
    files?: string[];
    nx?: NxProjectPackageJsonConfiguration;
    generators?: string;
    schematics?: string;
    builders?: string;
    executors?: string;
    'nx-migrations'?: string | NxMigrationsConfiguration;
    'ng-update'?: string | NxMigrationsConfiguration;
    packageManager?: string;
    description?: string;
    keywords?: string[];
}
export declare function normalizePackageGroup(packageGroup: PackageGroup): ArrayPackageGroup;
export declare function readNxMigrateConfig(json: Partial<PackageJson>): NxMigrationsConfiguration & {
    packageGroup?: ArrayPackageGroup;
};
export declare function buildTargetFromScript(script: string, scripts: Record<string, string>, packageManagerCommand: PackageManagerCommands): TargetConfiguration;
export declare function getMetadataFromPackageJson(packageJson: PackageJson, isInPackageManagerWorkspaces: boolean): ProjectMetadata;
export declare function getTagsFromPackageJson(packageJson: PackageJson): string[];
export declare function readTargetsFromPackageJson(packageJson: PackageJson, nxJson: NxJsonConfiguration, projectRoot: string, workspaceRoot: string): Record<string, TargetConfiguration<any>>;
/**
 * Uses `require.resolve` to read the package.json for a module.
 *
 * This will fail if the module doesn't export package.json
 *
 * @returns package json contents and path
 */
export declare function readModulePackageJsonWithoutFallbacks(moduleSpecifier: string, requirePaths?: string[]): {
    packageJson: PackageJson;
    path: string;
};
/**
 * Reads the package.json file for a specified module.
 *
 * Includes a fallback that accounts for modules that don't export package.json
 *
 * @param {string} moduleSpecifier The module to look up
 * @param {string[]} requirePaths List of paths look in. Pass `module.paths` to ensure non-hoisted dependencies are found.
 *
 * @example
 * // Use the caller's lookup paths for non-hoisted dependencies
 * readModulePackageJson('http-server', module.paths);
 *
 * @returns package json contents and path
 */
export declare function readModulePackageJson(moduleSpecifier: string, requirePaths?: string[]): {
    packageJson: PackageJson;
    path: string;
};
export declare function installPackageToTmp(pkg: string, requiredVersion: string): {
    tempDir: string;
    cleanup: () => void;
};
/**
 * Get the resolved version of a dependency from package.json.
 *
 * Retrieves a package version and automatically resolves PNPM catalog references
 * (e.g., "catalog:default") to their actual version strings. By default, searches
 * `dependencies` first, then falls back to `devDependencies`.
 *
 * **Tree-based usage** (generators and migrations):
 * Use when you have a `Tree` object, which is typical in Nx generators and migrations.
 *
 * **Filesystem-based usage** (CLI commands and scripts):
 * Use when reading directly from the filesystem without a `Tree` object.
 *
 * @example
 * ```typescript
 * // Tree-based - from root package.json (checks dependencies then devDependencies)
 * const reactVersion = getDependencyVersionFromPackageJson(tree, 'react');
 * // Returns: "^18.0.0" (resolves "catalog:default" if present)
 *
 * // Tree-based - check only dependencies section
 * const version = getDependencyVersionFromPackageJson(
 *   tree,
 *   'react',
 *   'package.json',
 *   ['dependencies']
 * );
 *
 * // Tree-based - check only devDependencies section
 * const version = getDependencyVersionFromPackageJson(
 *   tree,
 *   'jest',
 *   'package.json',
 *   ['devDependencies']
 * );
 *
 * // Tree-based - custom lookup order
 * const version = getDependencyVersionFromPackageJson(
 *   tree,
 *   'pkg',
 *   'package.json',
 *   ['devDependencies', 'dependencies', 'peerDependencies']
 * );
 *
 * // Tree-based - with pre-loaded package.json
 * const packageJson = readJson(tree, 'package.json');
 * const version = getDependencyVersionFromPackageJson(
 *   tree,
 *   'react',
 *   packageJson,
 *   ['dependencies']
 * );
 * ```
 *
 * @example
 * ```typescript
 * // Filesystem-based - from current directory
 * const reactVersion = getDependencyVersionFromPackageJson('react');
 *
 * // Filesystem-based - with workspace root
 * const version = getDependencyVersionFromPackageJson('react', '/path/to/workspace');
 *
 * // Filesystem-based - with specific package.json and section
 * const version = getDependencyVersionFromPackageJson(
 *   'react',
 *   '/path/to/workspace',
 *   'apps/my-app/package.json',
 *   ['dependencies']
 * );
 * ```
 *
 * @param dependencyLookup Array of dependency sections to check in order. Defaults to ['dependencies', 'devDependencies']
 * @returns The resolved version string, or `null` if the package is not found in any of the specified sections
 */
export declare function getDependencyVersionFromPackageJson(tree: Tree, packageName: string, packageJsonPath?: string, dependencyLookup?: PackageJsonDependencySection[]): string | null;
export declare function getDependencyVersionFromPackageJson(tree: Tree, packageName: string, packageJson?: PackageJson, dependencyLookup?: PackageJsonDependencySection[]): string | null;
export declare function getDependencyVersionFromPackageJson(packageName: string, workspaceRootPath?: string, packageJsonPath?: string, dependencyLookup?: PackageJsonDependencySection[]): string | null;
export declare function getDependencyVersionFromPackageJson(packageName: string, workspaceRootPath?: string, packageJson?: PackageJson, dependencyLookup?: PackageJsonDependencySection[]): string | null;
export {};
//# sourceMappingURL=package-json.d.ts.map